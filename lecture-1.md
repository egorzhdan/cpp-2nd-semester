Все будет показано на примере x86.

CPU взаимодействует с RAM командами: прочитать по адресу, записать данные по адресу.

На каждом шаге работы процессор пытается исполнить команду в ячейке с номером IP (instruction pointer).
Делает это миллиадры раз в секунду.

Пример команд:
```asm
mov dx,ax
add dx,cx
```

Будем смотреть на процессор 8086, ~70-х годов.
Кроме памяти у CPU есть 16-битные регистры, 8 штук.

## Команды:

### `MOV`
Самая простая команды, принимает источник и назначение и копирует значение.

Может использоваться чтобы читать и писать в RAM (например, `MOV AX, [10]` – считать 10-ю ячейку памяти в регистр AX).
При этом в x86 не поддерживает копирование из памяти в память.

### Простая арифметика: `ADD`, `SUB`, `AND`, `XOR`, `OR`

Тоже принимают 2 аргумента, то есть режим адресации reg-mem-2.

Еще есть бинарные команды `INC`, `DEC` – принимают один аргумент, прибавляют или вычитают 1 соответственно.
Могут принимать регистр или номер ячейки памяти.
```asm
INC AX
DEC AX

INC [BX]
INC [10]
```

### Унарные операции: `NEG` (унарный минус), `NOT` (побитовое отрицание, `~`)
```asm
NEG AX
NOT AX
```

Скомпилируем C++ код, вычислающий `a & b`, в ассемблер командой `g++ -O2 -S -masm=intel` и увидим там `MOV` и `AND`.

### `MUL`, `DIV`
`MUL` принимает один параметр – множитель, и умножает то, что лежит в регисте AX, на множитель.
Записывает 32-битный результат, разбивая на два 16-битных регистра – старшую часть в AX, младшую в BX.

Различные команды для знаковых и беззнаковых типов: `MUL` для знаковых, `IMUL` для беззнаковых.

`DIV` принимает один аргумент – делитель, и делит 32-битное число на 16-битный множитель, и записывает сразу и частное, и остаток в регистры AX и DX.
Аналогично знаковое деление – `IDIV`.

Если частное не помещается в 16 бит, или произошло деление на 0 – будет одна и та же ошибка процессора.

Но обычно делимое и делитель одной битности, тогда расширим делитель до 32 бит. (для беззнаковых нужно занулить регистр DX)
Чтобы занулить регистр, обычно используют `XOR DX DX`. Процессор знает эту команду и оптимизирует ее.

Еще есть команда `cwd`.

### `JMP`, ветвление
`JMP` – самая простая команда перехода, принимает куда перейти, и CPU начинает исполнять с этого места.
```asm
loop:   INC AXX
        JMP loop
```
Можно использовать метки, по аналогии с `goto`.

`JMP` кодируются относительно следующей после него команды. Позволяет прыгнуть только на -128..127.
Альтернативная форма `JMP` для такого кодируется немного иначе.

Умеем делать бесконечные циклы, теперь хочется делать условия.

Для условных переходов есть команды:
`je, jne` – jump if equal/not-equal
`jg, lng` – jump if greater (signed)

```asm
cmp ax,dx
je dest
```

Особый регистр FLAGS – состоит из отдельных битов, у каждого из них своя функция. У каждого свое название:
* C – carry flag (перенос)
* Z – zero flag
* S – sign flag
* O – overflow flag (переполнение)
* P – parity flag (четность)

Еще есть команды перехода по значению этих флагов:
* `jc/jnc` – jump if carry-flag / not-carry-flag
* etc

Команды `ADD` / `SUB` и другие меняют флаги следующим образом:
* `ZF` становится 1 когда результат операции равен 0
* `SF` становится 1 когда результат отрицательный
* `CF` становится 1 когда вышел за пределы 16 битов
* `OF` становится 1 когда произошло переполнение

Например, `je/jne` будет смотреть на ZF, поэтому это по сути та же команда, то `jz/jnz`.

Посмотрим на `jb` – беззнаковое `<`. Она соответствует CF и прыгает, если он установлен.

`ja` соответствует `!CF && !ZF`.

Рассмотрим `cmp a,b`. % FIXME тут должна быть пикча

Overflow – сложили 2 положительных и получили отрицательное, или 2 отрицательных и получили положительное.

`jl` соответствует `SF != OF`, `jg` соответствует `SF == OF && !ZF`.


Остальные команды тоже выставляют флаги, это бывает неожиданно.

Команда `test` – сделать `AND`, но не записывать результат, только поменять флаги.

```asm
loop:   mov dx,ax
        add ax,bx
        mov bx,dx
        dec cx
        jnz loop
```
– числа Фибоначчи.


Разобрали код для 1978 г. Теперь посмотрим, что поменялось.

В 1985 г. вышел процессор i386 – 32-битный процессор, регистры AX..DX остались 16-битные, но добавили новые регистры EAX..EDX, и они уже 32-битные.
EAX – это двойной регистр, его младшая половинка – это AX.

Потом AMD сделали 64-битный процессор, добавили регистры RAX..RDX.
RAX – это четверной регистр, его младшая половина – это EAX.
Также количество регистров расширили до 16. Им не дали имена, они называются R9..R16.

### Битовые сдвиги
* `SHL`
* `SHR` – unsigned
* `SAR` – signed, нужно сохранять бит знака


Команда деления работает сильно дольше, чем остальные (~40 тактов). Поэтому компиляторы стараются не вставлять команды деления.
Например, иногда можно использовать битовые сдвиги. А деление на 3 он заменит на `a/3 = (a*(2**N)/3)/(2**N)` – вместо деления получилось умножение.

Аргумент функции передается в регистре di (edi).

## Другие команды
### `LEA`

У команд в `[ ]` можно писать не только регистры. Там может быть `регистр + другой_регистр * (1 или 2 или 4 или 8) + const`, например, `[EBX + ECX*2 + IMM]`.
`LEA` похожа на команду чтения из памяти, записывается так же: `LEA EAX,[EBX + ECX*2 + IMM]`.
Это позволяет нам, например, складывать числа. Компиляторы этим пользуются. А для вычитания не подходит, приходится делать `SUB`.
Или когда умножаем на 2 или 4, тоже может подставить `LEA`.

### Набор команд `CMOVe`, `CMOVg`, `CMOVne`, etc
Условный переход, только если удовлетворено условие. Используется вместо обычного `JMP` для оптимизации.

Из 8 регистров, которые мы разобрали, есть один специальный – SP (или ESP/RSP, в зависимости от битности программы) (stack pointer, указатель на вершину стека, а точнее на младший разряд верхней команды).
Используется для работы со стеком вызовов функций.

Для него есть команды:
* `push eax` – `ESP = ESP - 4; [ESP] = EAX`
* `pop`: обратная операция – `EAX = [ESP]; ESP = ESP + 4`
Условный переход, только если удовлетворено условие. Используется вместо обычного `JMP` для оптимизации.

Чтобы вызывать функции, есть специальные команды:
* `call label` – похожа на `jmp`, только сначала делает `push address_of_next_instruction`, затем `jmp label`
* `ret`: парная команда – `pop tmp; jmp tmp`

## Как передаются аргументы
По-разному, зависит от calling convention.

В документах ABI прописано, как код на C должен компилироваться в ASM.

Если их не очень много (1, 2, 3), то они передаются в регистрах. А если их больше 6, то в регистры не влезут, и все регистры после 6-го пойдут через стек (будет `push`, но `pop` не будет, потому что сверху будет лежать адрес возврата).
Есть 2 способа передавать параметры функции через стек: слева-направо (Pascal) и справа-налево (С).
C делает в обратном порядке, потому что в C есть функции `printf("%d %d %d", 1, 2, 3)`. При ее выполнении нужно сначала посмотреть на строчку, чтобы понять, сколько параметров доставать.

### Создание stack frame

Заметим, что при компиляции без оптимизации появляются лишние команды. Так сложилось исторически, для отладчиков. Сейчас можно их не генерировать – `omit frame pointer`.

В стеке также лежат локальные переменные после адреса возврата. Когда стек сдвигается, на все локальные переменные ссылки меняются.
Чтобы не пересчитывать каждый раз адреса всех переменных, запомним в регистр `ebp` адрес начала локальных переменных в стеке.
У каждой функции `ebp` свой, поэтому каждая функция его сохраняет и восстанавливает.

В начале блока locals будет ссылка на `old_ebp` – ячейка стека со значением `ebp` предыдущей функции.
