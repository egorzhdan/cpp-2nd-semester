## Templates

Раньше было два подхода.

Можно было хранить `void*` – если данные меньше размера указателя, можно хранить их прямо на месте.
Если больше, то динамически выделять память. Это медленно.

Второй – генерировать код препроцессором:
```cpp
#define DECLARE_VECTOR(type) \
    struct vector_##type { \
    // ...
    }
```
Такое невозможно дебажить.

Теперь:
```cpp
template <typename T>
struct vector {
    T *data;
    size_t size, capacity;
}
```

Когда где-то используем `vector<int>`, компилятор берет шаблон и подставляет `int` вместо `T`.
Компилируется это медленнее, чем с `void*`, но это не столь важно.

Для функций:

```cpp
template <typename T>
T const& max(T const& a, T const& b) {
    return a < b ? a : b;
} 
```

Типы при вызове выводятся, но можно указать явно: `max<int>(1, 2)`.

Когда компилятор обрабатывает такую функцию, он помечает ее как `inline`.
Поэтому в нескольких единицах трансляции может быть `max<int>`,
и скомпилируется без ошибок.

Такие функции пишутся сразу в `.h`.


`newtype a(b)`: если b – тип, то это функция, иначе переменная.

`newtype a(T::foo)`: неясно, это тип или функция.
Имена вида `<темплейтный_параметр>::<что-либо>` – _зависимые имена_. 
Компилятор считает, что это название типа, только если перед ним написано `typename`.

`a < q > c` – можем прочитать как:
1. `(a < q) > c`
1. `a<q> c;`
Зависит от того, является ли `a` темплейтом.
Решение: `T::foo<q> c;`.

### Специализация

Иногда хочется поменять поведение темплейтного класса для конкретного типа. Это **полная инициализация**
Например, `vector<bool>` хранит по 8 `bool` в одном байте.
```cpp
template<>
struct vector<bool> {
    // ...
};
```

Также можно сделать `vector`, который работает иначе для указателей.
```cpp
template <typename U>
struct vector<U*> {
    // ...
}
```
Это **частичная инициализация**. Например, `vector<char*>` будет использовать ее, при этом `U` это `char`.

Выбирается каждый раз наиболее точная специализация. Если две версии одинаково специализированы, будет ошибка компиляции.
