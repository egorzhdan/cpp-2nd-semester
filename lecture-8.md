## Препроцессинг

```cpp
// x.h
struct x {};

// g.h
#include "x.h"

// z.h
#include "x.h"

// a.cpp
#include "g.h"
#include "z.h"
```

– ошибка трансляции, `x` объявлена дважды.

Можно удалить из `g.h` `#include "x.h"`, но это неудобно.

Поэтому делают _include guard_ (так, как CLion по умолчанию).

### Макросы

* `#define`
* `#ifdef`
* `#ifndef`
* `#else`
* `#endif`

```cpp
// x.h

#ifndef X_H
#define X_H

struct x {};

#endif
```

Директива компилятора, чтобы не писать самому этот код, а сделать автоматически: `#pragma once`

Программа с рекурсивными `struct` не скомпилируется, для этого нужно использовать _forward declaration_.
Иногда лучше использовать ее вместо `include`, даже если нет такой ситуации. 
Например, чтобы не перекомпилировать много файлов.

Когда макрос пытается раскрыться изнутри самого себя, он не раскрывается.

Конкатенацияв макросе: `#define T(x) x##keyword`. В такой ситуации аргументы конкатенации не препроцессируются.
