# Undefined behavior

```cpp
void sum(float *result, float const* arr, size_t n) {
    for (size_t i = 0; i != n; ++i) {
        *result += arr[i];
    }
}
```
– будет каждый раз записывать в `result`, и не читать оттуда.

Разные указатели могут перекрываться (_aliasing_), и это не дает компилятору соптимизировать.

В C99 добавили спецификатор `restrict` – значит указатель не перекрывается ни с каким другим в этой области программы.
Если все таки передадим туда перекрывающиеся указатели – undefined behavior.

* знаковое переполнение
* сдвиг положительного числа на >31
* использование обеих переменных в union

Если есть указатели на разные типы (`float*` и `int*`), то компилятор считает, что это указатели на разную память – _type-based aliasing_ –
если не `char*`.

Еще бывает undefined behavior на уровне библиотеки:
* прохой компаратор (нетранзитивный/...)
* неотсортированный массив в `upper_bound` 
* изменили хеш объекта, когда он лежит в хеш-таблице
