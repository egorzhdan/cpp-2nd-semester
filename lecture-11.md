## Наследование и виртуальные функции

```cpp
struct base {
    int a;
    int b;
}

struct derived: base {
    int c;
    int d;
}

derived x;

// x.a, x.b, x.c, x.d
```

А если бы названия совпадали:

```cpp
struct derived: base {
    int b;
    int c;
}

derived x;
// x.b – возьмет из derived

base y = x;
// y.b – возьмет из base
```

```cpp
void f(base &y) {
    derived& x = (derived&) y;
    // x.b, x.c
    // в общем случае такой каст делать нельзя
}
```

Стандарт запрещает такой каст.

Наследование отличается от такой конструкции: `y.base.a`, потому что неясно, как делать обратный каст.
Можно сдвигаться влево на размер родительских классов в памяти. В C есть макрос `offsetof`, который ровно это и говорит.

_Статический тип_ – тот, который указан при объявлении функции. <br>
_Динамический тип_ – тот, который на самом деле передали.

```cpp
base b;
derived d;

b.f();
d.f();
// – работает так же, как с переменными
```

Если хотим уточнить, из какого родителя запустить функцию, можно квалифицировать имя: `base::g();`,
еще это работает снаружи класса: `g.base::g();` 

Функции можно пометить **virtual**:

```cpp
struct base {
    void f();
    virtual void g();
}
```

Вызовется функция, которая нашлась бы, если бы вызывали не по статическому типу, а по динамическому.

Модификатор `virtual` можно написать только один раз – в базе.

**Полиморфизм** – ...

Можно делать деструктор класса виртуальным.

### Абстрактные функции

Иногда для базы нельзя написать адекватную реализацию:

```cpp
struct data_source {
    virtual void read() = 0;
}
``` 

Это сделает класс абстрактным, то есть его экземпляр нельзя создать.

Для такой функции все равно можно указать тело.

### Модификатор protected

Для наследования появился модификатор `protected` – к таким переменным или функциям есть доступ только у наследников.

Тут есть дилемма – может ли protected функция ломать инвариант класса? Если нет, то она может быть просто public.
