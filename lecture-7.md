Тип результата функции не всегда пишется слева

```cpp
float (*f())(int, int)

float (*g)(int, int) = f();
```

но такие типы пишут редко

### typedef

```cpp
// <cstdint>

typedef int int32_t; 
```

```cpp
typedef int **(**type[10][20])[30][40]; // синтаксис как у объявления переменной
type a;
```

# Процесс компипяции

```
1.cpp
  |
  |     – препроцессирование
  |
 1.i
  |
  |     – трансляция
  |
 1.s
  |
  |     – ассемблирование
  |
 1.o                        2.o                        3.o
 
 – для каждого файла по отдельности
  |                          |                          |
   ----------------------------------------------------- 
                             |
                             | – cобирание всех в одну программу
                             |
                          program
```

Сделать только препроцессинг: `g++ -E -P`

Препроцессор обрабатывает директивы `include`, а оканчивается `1.i` обычным кодом.

Трансляция: `g++ -S [-masm=intel] 1.i`

Посмотреть бинарный файл: `xxd 1.o`, дизассемблировать: `objdump -S 1.o`

Линковка: `g++ 1.o`

`g++` запускает разные стадии компиляции в нужном порядке. 
При этом если файл не изменился, то, например, `make`, не будет пересобирать лишнее.

Препроцессирование и трансляцию обычно делает одна программа – _integrated assembly_.

```cpp
// b.cpp

#include <cstdio>

void f() {
    printf("Hello world!")
}
```

```cpp
// a.cpp

int main() {
    f();
}
```

– возникает ошибка компиляции на этапе трансляции.

Объявим функцию:

```cpp
// a.cpp

void f();

int main() {
    f();
}
```

– теперь ассемблируется без ошибок.

Каждый из них по отдельности не получится слинковать.

Транслятор идет сверху вниз по программе.

```cpp
// a.cpp

void f();

int main() {
    f();
}

void f() {
    // ...
}
```

### Header files

В `1.h` только объявления функции, в `1.cpp` тело функции.

Инклюдить `.cpp` не стоит, и писать в `.h` коды функций тоже не стоит, иначе будет конфликт линковки.

Если в одном `.h` файле объявить одну функцию, и заинклюдить в два других файла, один из которых запустим,
будет ошибка компиляции. Ее решения: 
1. Модификатор `inline` – компилятор не обязан на самом деле инлайнить, но от этого не зависит результат
(тогда компилятор понимает, что все копии этой функции одинаковые, так что можно оставить любую из них).

Единица трансляции – разные места, где она проимходит (файлы).

Можно пометить функцию как `static` – она будет локальной для текущей единицы трансляции.

Декларация переменной: `extern int a` – значит, что переменная определена в другой единице трансляции.

В новых C++ переменные тоже можно делать `inline`, но пока что компиляторы это обычно не поддерживают.

