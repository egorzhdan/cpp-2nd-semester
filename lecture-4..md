Уточним модель процессора.

<тут много оффтопа про кеш>

_пример про заполнение матриц_

В районе степеней 2 резкие пики по времени. Это связано с размерами кеш-линий.
Ключом в хеш-таблице кеша является адрес памяти, значением – то, что там лежит.

Особенно плохо со степенями 2 из-за коллизий хеш-функции –
для нее выбрали просто младшие биты адреса.

**Аппаратный префетчинг** позволяет процессору заранее подгрузить в кеш
данные, которые скорее всего будут запрошены.

Примерно каждая пятая команда – это условный переход. Поэтому глубокие pipeline
делать было бы бессмысленно. Но есть **branch prediction**.
Он в основном угадывает циклы.

Пример замедления из-за фейлов predictor-а: linear feedback shift register.

Без `-fno-if-conversion[2]` разница не видна.

Пример кода, где плохо предсказывается: количество вхождений каждого символа
в Хаффмане. На случайных значениях очень быстро, а если все одинаковые, то
в 3 раза медленнее.

Если условие очень плохо предсказывается, то есть смысл заменить на `cmov`.
Иначе можно оставлять `if`, потому что не всегда нужно считать все условие.

### Полезные команды

1. `adc` – почти `add`, но не `x = x + 4`, а `x = x + y + CARRY_FLAG`
1. `sbb` – аналогично, но `x = x - y - CARRY_FLAG`
